---
title: "Matching project"
author: "Nadir Nibras"
date: "January 30, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(root.dir = "C:/Users/nadir/Desktop/Matching/BKN 599 Advanced Data Analysis")

```


## Matching project for evaluating effects of treatment dosage

clear workspace variables
```{r}
rm(list = ls()); 
```

clear command window (same as ctrl+L. )
```{r}
cat("\014")  
```

close all plots
```{r}
graphics.off() 
```

```{r}
library(tidyverse)
library(Matching)
# library(dummy)
# library(dummies)
# library(MatchIt)
# library(RItools)
# library(rbounds)
```

variables
```{r}
threshold= 27
replace= 1
```

Read files
```{r}
setwd("C:/Users/nadir/Desktop/Matching/BKN 599 Advanced Data Analysis")

evalData=read.csv("00042_evalDataset_notext.csv")
patChar= read.csv("PatientCharacteristics_withDose.csv")
```

Changing column name for merging
```{r}
names(patChar)[6]<-paste("pid")  
```

Remove sparse features/features with no use
```{r}
evalData= evalData[-c(1:4, 7:203, 205:245, 247:276, 278:366, 369:376)]  
patChar= patChar[c(6,9,12,18,19,27,29,30)]
```
Note: Leaving out FAS scores because many (18) missed values for visit 1 stats


Merge data
```{r}
dataMerged= merge(evalData,patChar)
```

Feature manipulation
```{r}
dataMerged$severity= ifelse(dataMerged$severity=="H", 1, 0)
dataMerged$finished_college=ifelse(dataMerged$DEMOedu>4,1,0)
dataMerged$DEMOedu=NULL
```


Replace -99 with missing values
```{r}
dataMerged[dataMerged == -99] <- NA
```


Changing table to numeric
```{r}
for (i in 2:ncol(dataMerged)){
  dataMerged[c(i)]= as.numeric(unlist(dataMerged[c(i)]))
}
```

Extract visit datas
```{r}
dataVisit1= subset(dataMerged, visitnum==1)                        
dataVisit2= subset(dataMerged, visitnum==2)                        
```

Removing visit2 data with missing values for NIHtotal
```{r}
dataVisit2= dataVisit2[complete.cases(dataVisit2[,5]),]

```

Removing visit1 data with no available visit 2 features
```{r}
temp= data.frame(dataVisit2$pid); 
names(temp)[1]<-paste("pid");   #renaming column name to "pid"
dataVisit1= merge(temp,dataVisit1)
rm(temp)

```

Check number of missing values
```{r}
sum(is.na(dataVisit1))
sum(is.na(dataVisit2))

```

Impute missing values- is.na(dataVisit1[,i]) returns TRUE only for row index of column with NA
```{r}
for(i in 2:ncol(dataVisit1)){
  dataVisit1[is.na(dataVisit1[,i]), i] <- median(dataVisit1[,i], na.rm = TRUE)
}  
for(i in 2:ncol(dataVisit2)){
  dataVisit2[is.na(dataVisit2[,i]), i] <- median(dataVisit2[,i], na.rm = TRUE)
}

```


Check number of missing values AGAIN
```{r}
sum(is.na(dataVisit1))
sum(is.na(dataVisit2))
```


Creating new dataset for future calculations
```{r}
data12= dataVisit1
```
#### Note: The Low Dose group is the treated group, and High Dose is the control group for matching
creating binary variable indicating whether subject belongs in Low Dose or High Dose group  
```{r}
data12$treat=ifelse(dataVisit1$dose_hours<=threshold, 1, 0)
```


normalize by subtracting mean and dividing by std (doing min-max instead)
```{r}
# for(i in 2:(ncol(data12)-1)){
#   data12[,i] <- (data12[,i]-mean(data12[,i]))/(max(data12[,i])-min(data12[,i]))
# }
```

Creating change parameters from differences in visit2 and vist 1
```{r}

data12$sishand_change= dataVisit2$SIS_hand-dataVisit1$SIS_hand
data12$fugm_change= dataVisit2$ufugm-dataVisit1$ufugm
data12$logwmftMA_change= dataVisit2$log_mean_time_MA_PA-dataVisit1$log_mean_time_MA_PA
data12$logwmftLA_change= dataVisit2$log_mean_time_LA_PA-dataVisit1$log_mean_time_LA_PA
```

Creating 2 dataframes separatomg low dose and high dose (not used)
```{r}
highdosegroup= subset(data12, treat==0)
lowdosegroup= subset(data12, treat==1)

```

saving indexes
```{r}
# highdoseindex= which(dataVisit1$dose_hours>threshold)
# lowdoseindex= which(dataVisit1$dose_hours<=threshold)

```


plotting change in fugl-meyer score across all patients
```{r}
ggplot(data12,aes(fugm_change))+
  geom_histogram(fill="white", col="black", binwidth = 1)

```


### Propensity Score Matching code starts here (Youtube tutorial used)

creates a marrix from columns/features
```{r}
X= cbind(data12$SIS_hand, data12$ufugm,data12$CSgender,data12$NIHtot, 
         data12$log_mean_time_MA_PA, data12$log_mean_time_LA_PA,
         data12$severity, data12$onset_to_rand, data12$age_at_rand,
         data12$concordance, data12$finished_college)

```

Output variable that we will use to evaluate causality after matching
```{r}
y=data12$logwmftMA_change

```

### Calculating the propensity score
Generalized linear models are fit using the glm( ) function.

treat ~ X means treat is the response of all other variables
treat is a binary factor and x is a matrix of all predictor variables  

Family objects provide a convenient way to specify the details of the models used by functions such as glm

family= binomial() performs Logistic Regression


```{r}
model <- glm(treat ~ X, 
             family = binomial(), data = data12)
```

Subjects are more likely to be in treated (Low Dose) group if "Estimate" values are positive
```{r}
summary(model) 

```

### Matching and estimating effects of causality using "Match" package

"Match"" implements a variety of algorithms for multivariate matching including propensity score, Mahalanobis and inverse variance matching. The function is intended to be used in conjunction with the MatchBalance function which determines the extent to which Match has been able to achieve covariate balance

- Y=y
A vector containing the outcome of interest. Missing values are not allowed. An outcome vector is not required because the matches generated will be the same regardless of the outcomes. Of course, without any outcomes no causal effect estimates will be produced, only a matched dataset.

- X= model$fitted.values
A matrix containing the variables we wish to match on. This matrix may contain the actual observed covariates or the propensity score or a combination of both. All columns of this matrix must have positive variance or Match will return an error
Note: In our case it is the propensity score (fitted.values are predicted values for log regr.)

- estimand = "ATT"
A character string for the estimand. The default estimand is "ATT", the sample average treatment effect for the treated. "ATE" is the sample average treatment effect, and "ATC" is the sample average treatment effect for the controls.

- M = 1
A scalar for the number of matches which should be found. The default is one-to-one matching. Also see the ties option

- ties = FALSE
A logical flag for whether ties should be handled deterministically. By default ties==TRUE. If, for example, one treated observation matches more than one control observation, the matched dataset will include the multiple matched control observations and the matched data will be weighted to reflect the multiple matches
If ties==FALSE, ties will be randomly broken. If the dataset is large and there are many ties, setting ties=FALSE often results in a large speedup. Whether two potential matches are close enough to be considered tied

-replace = TRUE
Matching with replacement

####Matching using ATT and ATE
```{r}
rr1 =Match(Y=y, Tr= data12$treat, X= model$fitted.values, estimand = "ATT", 
           M=1, ties= FALSE, replace= TRUE)

# rr2 =Match(Y=y, Tr= data12$treat, X= model$fitted.values, estimand = "ATE", 
#            M=1, ties= FALSE, replace= TRUE)
```

####Checking unique values of matched subjects
```{r}
length(unique(rr1$index.treated))
length(unique(rr1$index.control))

# length(unique(rr2$index.treated))
# length(unique(rr2$index.control))
# 
```


####Assessing balance
"MatchBalance" is used to determine if Match was successful in achieving balance on the observed covariates.

-treat~SIS_hand+ ...
This formula does not estimate any model. The formula is simply an efficient way to use the R modeling language to list the variables we wish to obtain univariate balance statistics for. The dependent variable in the formula is usually the treatment indicator

-nboots= 0
The number of bootstrap samples to be run. If zero, no bootstraps are done. Bootstrapping is highly recommended because the bootstrapped Kolmogorov-Smirnov test provides correct coverage even when the distributions being compared are not continuous. At least 500 nboots (preferably 1000) are recommended for publication quality p-values.

```{r}
MatchBalance(treat~ SIS_hand + ufugm + NIHtot + log_mean_time_MA_PA +
               log_mean_time_LA_PA +CSgender+ concordance + severity + 
               onset_to_rand + finished_college + age_at_rand,
             match.out= rr1, nboots=100,data= data12)

# MatchBalance(treat~ SIS_hand + ufugm + NIHtot + log_mean_time_MA_PA +
#                log_mean_time_LA_PA +CSgender+ concordance + severity + 
#                onset_to_rand + finished_college + age_at_rand,
#              match.out= rr2, nboots=100,data= data12)
```


####Summary of the model will tell us about Causal relationship on picked Y after Matching

```{r}

summary(rr1) 
# summary(rr2)
```

####Further assessing balance- Plotting matched values for SIS Hand and Log mean time for WMFT
```{r}
qqplot(data12$SIS_hand[rr1$index.control],data12$SIS_hand[rr1$index.treated])
abline(coef=c(0,1),col=2)

qqplot(data12$log_mean_time_MA_PA[rr1$index.control],data12$log_mean_time_MA_PA[rr1$index.treated])
abline(coef=c(0,1),col=2)

```

### Genetic matching 
This function finds optimal balance using multivariate matching where a genetic search algorithm determines the weight each covariate is given. Balance is determined by examining cumulative probability distribution functions of a variety of standardized statistics. By default, these statistics include t-tests and Kolmogorov-Smirnov tests. A variety of descriptive statistics based on empirical-QQ (eQQ) plots can also be used or any user provided measure of balance. The statistics are not used to conduct formal hypothesis tests, because no measure of balance is a monotonic function of bias and because balance should be maximized without limit. The object returned by GenMatch can be supplied to the Match function (via the Weight.matrix option) to obtain causal estimates. GenMatch uses **GENoud** to perform the genetic search. 

- Tr= data12$treat
A vector indicating the observations which are in the treatment regime and those which are not. This can either be a logical vector or a real vector where 0 denotes control and 1 denotes treatment.

- X=X
A matrix containing the variables we wish to match on. 
#####This matrix may contain the actual observed covariates or the propensity score or a combination of both.

- pop.size= 200
Population Size. This is the number of individuals genoud uses to solve the optimization problem. The theorems proving that genetic algorithms find good solutions are asymptotic in population size. Therefore, it is important that this value not be small. See genoud for more details.

**GENoud**- GENetic Optimization Using Derivatives
Genoud is a function that combines evolutionary search algorithms with derivative-based (Newton or quasi-Newton) methods to solve difficult optimization problems.

```{r}
# Adding propensity score to estimation
X1 = cbind(X,model$fitted.values)

gen1 = GenMatch(Tr= data12$treat, X=X, pop.size=200, replace=TRUE)
mgen1=Match(Y=y, Tr=data12$treat, X=X, Weight.matrix = gen1)

```

####Summary of the model will tell us about Causal relationship
```{r}
summary(mgen1)

```


#### Assessing balance
```{r}
MatchBalance(treat~ SIS_hand + ufugm + NIHtot + log_mean_time_MA_PA +
               log_mean_time_LA_PA +CSgender+ concordance + severity + 
               onset_to_rand + finished_college + age_at_rand,
             data= data12, match.out= mgen1, nboots=0)

```
####Further assessing balance- Plotting matched values for SIS Hand and Log mean time for WMFT
```{r}

qqplot(data12$SIS_hand[mgen1$index.control],data12$SIS_hand[mgen1$index.treated])
abline(coef=c(0,1),col=2)

qqplot(data12$log_mean_time_MA_PA[mgen1$index.control],data12$log_mean_time_MA_PA[mgen1$index.treated])
abline(coef=c(0,1),col=2)

```
```{r}
length(unique(mgen1$index.treated))
length(unique(mgen1$index.control))
```



#### GGplot
```{r}
x= data12$SIS_hand[mgen1$index.control]
y= data12$SIS_hand[mgen1$index.treated]
df= data.frame(x,y)
# library(ggplot2)
ggplot(df, aes(x,y))+
  geom_point()
ggplot(df, aes(x,y))+
  geom_jitter()

```


#### Checking the correlation
```{r}
R2_with_replace= cor(data12$log_mean_time_MA_PA[mgen1$index.control],data12$log_mean_time_MA_PA[mgen1$index.treated])^2
R2_with_replace

```

```{r}

```

